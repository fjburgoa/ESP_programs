/*
Creado por Javier Burgoa el 22/11/24 para simular un deadlock
y resolverlo.

*/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"
#include "driver/gpio.h"
#include "esp_adc/adc_oneshot.h"
#include "driver/ledc.h"
#include "esp_timer.h"
#include "driver/uart.h"

//CONTADORES
#define ITER_A 400000
#define ITER_B 400000

//GPIO SALIDAS Y ENTRADAS DIGITALES
#define BOOT 0
#define LED4 4
#define LED6 6

#define STACK_SIZE	4*1024	     //N x 1kByte es el tama√±o de la piLa  

static SemaphoreHandle_t xMutex1;
static SemaphoreHandle_t xMutex2;

//-----------------------------------------------------------------------------------------
void TareaA( void * pvParameters )
{
    while(1)
    {
       if (xSemaphoreTake(xMutex1, 1000/portTICK_PERIOD_MS)== pdTRUE)
       {
            printf("La tarea A ha cogido el mutex 1\n");                   //imprime por el terminal
            vTaskDelay(1/portTICK_PERIOD_MS);

            if (xSemaphoreTake(xMutex2, 1000/portTICK_PERIOD_MS)== pdTRUE)
            {
                printf("La tarea A ha cogido el mutex 2\n");               //imprime por el terminal 
                for (long i = 0; i < ITER_A; i++) {   __asm__ __volatile__("NOP");     }
                xSemaphoreGive(xMutex2); 
            }
            else
            {
                printf("La tarea A no ha podido coger el mutex 2\n");      //imprime por el terminal 
            }
            xSemaphoreGive(xMutex1);
        }
        else
        {
            printf("La tarea A no ha podido coger el mutex 1\n");           //imprime por el terminal 
        }

        printf("Task A going to sleep\n");
        vTaskDelay(400 / portTICK_PERIOD_MS);
    }	
}

//-----------------------------------------------------------------------------------------
void TareaB( void * pvParameters )
{
    while(1)
    {
        if (xSemaphoreTake(xMutex2, 1000/portTICK_PERIOD_MS)== pdTRUE)
        {
           printf("La tarea B ha cogido el mutex 2\n");                   //imprime por el terminal
           vTaskDelay(2/portTICK_PERIOD_MS);       
           
           if(xSemaphoreTake(xMutex1, 1000/portTICK_PERIOD_MS)== pdTRUE)
           {
               printf("La tarea B ha cogido el mutex 1\n");               //imprime por el terminal
               for (long i = 0; i < ITER_B; i++) {   __asm__ __volatile__("NOP");     }
               xSemaphoreGive(xMutex1);
           }
           else
           {
               printf("La tarea B no ha podido coger el mutex 2\n");      //imprime por el terminal 
           }
           xSemaphoreGive(xMutex2);
        }
        else
        {
           printf("La tarea B no ha podido coger el mutex 1\n");           //imprime por el terminal 
        }

        printf("Task B going to sleep\n");
        vTaskDelay(400 / portTICK_PERIOD_MS);
    }	
}
//-----------------------------------------------------------------------------------------


void app_main(void) 
{   
    xMutex1 = xSemaphoreCreateMutex();                                  //mutex
    xMutex2 = xSemaphoreCreateMutex();                                  //mutex
 
    TaskHandle_t xHandle1 = NULL;                                       //Handler a la tarea A
    TaskHandle_t xHandle2 = NULL;                                       //Handler a la tarea B
    
    xTaskCreate( TareaA, "TAREA_A", STACK_SIZE, NULL, 2, &xHandle1 );   //Crea la tarea
    xTaskCreate( TareaB, "TAREA_B", STACK_SIZE, NULL, 1, &xHandle2 );   //Crea la tarea 2 con mayor prioridad

    while (1) 
    {
    }
}
